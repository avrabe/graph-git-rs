//! Tests for BitBake configuration generation
//!
//! Tests local.conf, bblayers.conf, and environment setup generation.

use convenient_kas::config_generator::ConfigGenerator;
use convenient_kas::include_graph::{KasConfig, KasHeader, KasLayer, KasRepo};
use std::collections::HashMap;
use tempfile::TempDir;
use tokio::fs;

#[tokio::test]
async fn test_generate_local_conf_basic() {
    let temp = TempDir::new().unwrap();

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("qemux86-64".to_string()),
        distro: Some("poky".to_string()),
        target: Some(vec!["core-image-minimal".to_string()]),
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    generator.generate_all().await.unwrap();

    let local_conf_path = temp.path().join("conf/local.conf");
    assert!(local_conf_path.exists());

    let content = fs::read_to_string(&local_conf_path).await.unwrap();

    // Check header
    assert!(content.contains("local.conf - Generated by Bitzel"));

    // Check machine and distro
    assert!(content.contains("MACHINE ?= \"qemux86-64\""));
    assert!(content.contains("DISTRO ?= \"poky\""));

    // Check default directories
    assert!(content.contains("TMPDIR"));
    assert!(content.contains("DL_DIR"));
    assert!(content.contains("SSTATE_DIR"));

    // Check Bitzel cache
    assert!(content.contains("BITZEL_CACHE_DIR"));

    // Check build parallelism
    assert!(content.contains("BB_NUMBER_THREADS"));
    assert!(content.contains("PARALLEL_MAKE"));
}

#[tokio::test]
async fn test_generate_local_conf_with_headers() {
    let temp = TempDir::new().unwrap();

    let mut headers = HashMap::new();
    headers.insert(
        "custom".to_string(),
        "CUSTOM_VAR = \"value\"\nANOTHER_VAR = \"test\"".to_string(),
    );
    headers.insert("debug".to_string(), "DEBUG_BUILD = \"1\"".to_string());

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("qemux86-64".to_string()),
        distro: Some("poky".to_string()),
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: Some(headers),
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    generator.generate_all().await.unwrap();

    let local_conf_path = temp.path().join("conf/local.conf");
    let content = fs::read_to_string(&local_conf_path).await.unwrap();

    // Check custom headers are included
    assert!(content.contains("CUSTOM_VAR = \"value\""));
    assert!(content.contains("ANOTHER_VAR = \"test\""));
    assert!(content.contains("DEBUG_BUILD = \"1\""));
    assert!(content.contains("Section: custom"));
    assert!(content.contains("Section: debug"));
}

#[tokio::test]
async fn test_generate_bblayers_conf_basic() {
    let temp = TempDir::new().unwrap();

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("qemux86-64".to_string()),
        distro: None,
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    generator.generate_all().await.unwrap();

    let bblayers_path = temp.path().join("conf/bblayers.conf");
    assert!(bblayers_path.exists());

    let content = fs::read_to_string(&bblayers_path).await.unwrap();

    // Check header
    assert!(content.contains("bblayers.conf - Generated by Bitzel"));

    // Check version
    assert!(content.contains("LCONF_VERSION = \"7\""));

    // Check BBPATH and BBFILES
    assert!(content.contains("BBPATH = \"${TOPDIR}\""));
    assert!(content.contains("BBFILES ?= \"\""));

    // Check BBLAYERS
    assert!(content.contains("BBLAYERS ?="));
}

#[tokio::test]
async fn test_generate_bblayers_conf_with_layers() {
    let temp = TempDir::new().unwrap();

    // Create layer paths
    let layer1 = temp.path().join("layers/meta");
    let layer2 = temp.path().join("layers/meta-poky");
    let layer3 = temp.path().join("layers/meta-oe");

    let mut layer_paths = HashMap::new();
    layer_paths.insert("poky".to_string(), vec![layer1.clone(), layer2.clone()]);
    layer_paths.insert("meta-oe".to_string(), vec![layer3.clone()]);

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("test".to_string()),
        distro: None,
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, layer_paths);
    generator.generate_all().await.unwrap();

    let bblayers_path = temp.path().join("conf/bblayers.conf");
    let content = fs::read_to_string(&bblayers_path).await.unwrap();

    // Check all layers are included
    assert!(content.contains(&layer1.to_string_lossy().to_string()));
    assert!(content.contains(&layer2.to_string_lossy().to_string()));
    assert!(content.contains(&layer3.to_string_lossy().to_string()));
}

#[tokio::test]
async fn test_generate_bblayers_conf_with_headers() {
    let temp = TempDir::new().unwrap();

    let mut headers = HashMap::new();
    headers.insert("custom".to_string(), "BBMASK = \"test\"".to_string());

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("test".to_string()),
        distro: None,
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: Some(headers),
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    generator.generate_all().await.unwrap();

    let bblayers_path = temp.path().join("conf/bblayers.conf");
    let content = fs::read_to_string(&bblayers_path).await.unwrap();

    // Check custom header
    assert!(content.contains("BBMASK = \"test\""));
    assert!(content.contains("Section: custom"));
}

#[tokio::test]
async fn test_generate_env_setup() {
    let temp = TempDir::new().unwrap();

    let mut env = HashMap::new();
    env.insert("SSTATE_DIR".to_string(), "/shared/sstate".to_string());
    env.insert("DL_DIR".to_string(), "/shared/downloads".to_string());

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("qemux86-64".to_string()),
        distro: Some("poky".to_string()),
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: Some(env),
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    generator.generate_env_setup().await.unwrap();

    let env_setup_path = temp.path().join("setup-environment");
    assert!(env_setup_path.exists());

    let content = fs::read_to_string(&env_setup_path).await.unwrap();

    // Check shebang
    assert!(content.starts_with("#!/bin/bash"));

    // Check header
    assert!(content.contains("Environment setup script generated by Bitzel"));

    // Check build directory export
    assert!(content.contains("export BUILDDIR="));

    // Check custom environment variables
    assert!(content.contains("export SSTATE_DIR=\"/shared/sstate\""));
    assert!(content.contains("export DL_DIR=\"/shared/downloads\""));

    // Check machine and distro display
    assert!(content.contains("Machine: qemux86-64"));
    assert!(content.contains("Distro: poky"));

    // Check it's executable on Unix
    #[cfg(unix)]
    {
        let metadata = fs::metadata(&env_setup_path).await.unwrap();
        let permissions = metadata.permissions();
        use std::os::unix::fs::PermissionsExt;
        assert_eq!(permissions.mode() & 0o111, 0o111); // Executable bits set
    }
}

#[tokio::test]
async fn test_get_targets_default() {
    let temp = TempDir::new().unwrap();

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("test".to_string()),
        distro: None,
        target: None, // No target specified
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    let targets = generator.get_targets();

    // Should default to core-image-minimal
    assert_eq!(targets.len(), 1);
    assert_eq!(targets[0], "core-image-minimal");
}

#[tokio::test]
async fn test_get_targets_custom() {
    let temp = TempDir::new().unwrap();

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("test".to_string()),
        distro: None,
        target: Some(vec![
            "core-image-minimal".to_string(),
            "core-image-sato".to_string(),
        ]),
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
    let targets = generator.get_targets();

    assert_eq!(targets.len(), 2);
    assert_eq!(targets[0], "core-image-minimal");
    assert_eq!(targets[1], "core-image-sato");
}

#[tokio::test]
async fn test_generate_all_creates_conf_directory() {
    let temp = TempDir::new().unwrap();

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("test".to_string()),
        distro: None,
        target: None,
        repos: HashMap::new(),
        bblayers_conf_header: None,
        local_conf_header: None,
        env: None,
    };

    let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());

    // conf directory shouldn't exist yet
    let conf_dir = temp.path().join("conf");
    assert!(!conf_dir.exists());

    generator.generate_all().await.unwrap();

    // conf directory should be created
    assert!(conf_dir.exists());
    assert!(conf_dir.join("local.conf").exists());
    assert!(conf_dir.join("bblayers.conf").exists());
}

#[tokio::test]
async fn test_config_generator_with_all_features() {
    let temp = TempDir::new().unwrap();

    // Create comprehensive config
    let mut repos = HashMap::new();
    repos.insert(
        "poky".to_string(),
        KasRepo {
            url: Some("https://git.yoctoproject.org/git/poky".to_string()),
            refspec: None,
            branch: Some("kirkstone".to_string()),
            commit: None,
            tag: None,
            path: None,
            layers: {
                let mut layers = HashMap::new();
                layers.insert("meta".to_string(), KasLayer { path: None });
                layers.insert("meta-poky".to_string(), KasLayer { path: None });
                layers
            },
            patches: None,
        },
    );

    let mut local_conf_headers = HashMap::new();
    local_conf_headers.insert("custom".to_string(), "CUSTOM = \"value\"".to_string());

    let mut bblayers_headers = HashMap::new();
    bblayers_headers.insert("mask".to_string(), "BBMASK = \"test\"".to_string());

    let mut env = HashMap::new();
    env.insert("SSTATE_DIR".to_string(), "/cache/sstate".to_string());

    let config = KasConfig {
        header: KasHeader {
            version: 14,
            includes: None,
        },
        machine: Some("qemux86-64".to_string()),
        distro: Some("poky".to_string()),
        target: Some(vec!["core-image-minimal".to_string()]),
        repos,
        bblayers_conf_header: Some(bblayers_headers),
        local_conf_header: Some(local_conf_headers),
        env: Some(env),
    };

    let layer1 = temp.path().join("poky/meta");
    let layer2 = temp.path().join("poky/meta-poky");
    let mut layer_paths = HashMap::new();
    layer_paths.insert("poky".to_string(), vec![layer1.clone(), layer2.clone()]);

    let generator = ConfigGenerator::new(temp.path(), config, layer_paths);

    // Generate all configurations
    generator.generate_all().await.unwrap();
    generator.generate_env_setup().await.unwrap();

    // Verify all files exist
    assert!(temp.path().join("conf/local.conf").exists());
    assert!(temp.path().join("conf/bblayers.conf").exists());
    assert!(temp.path().join("setup-environment").exists());

    // Verify local.conf content
    let local_conf = fs::read_to_string(temp.path().join("conf/local.conf"))
        .await
        .unwrap();
    assert!(local_conf.contains("qemux86-64"));
    assert!(local_conf.contains("poky"));
    assert!(local_conf.contains("CUSTOM = \"value\""));

    // Verify bblayers.conf content
    let bblayers = fs::read_to_string(temp.path().join("conf/bblayers.conf"))
        .await
        .unwrap();
    assert!(bblayers.contains("BBMASK = \"test\""));
    assert!(bblayers.contains(&layer1.to_string_lossy().to_string()));

    // Verify setup-environment content
    let env_setup = fs::read_to_string(temp.path().join("setup-environment"))
        .await
        .unwrap();
    assert!(env_setup.contains("SSTATE_DIR=\"/cache/sstate\""));
}
