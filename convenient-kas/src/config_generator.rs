//! BitBake configuration generation from kas config
//!
//! Generates local.conf, bblayers.conf, and other configuration files
//! needed for BitBake builds from merged kas configuration.

use crate::include_graph::KasConfig;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Configuration generator
pub struct ConfigGenerator {
    build_dir: PathBuf,
    kas_config: KasConfig,
    layer_paths: HashMap<String, Vec<PathBuf>>,
}

impl ConfigGenerator {
    /// Create a new config generator
    pub fn new(
        build_dir: impl AsRef<Path>,
        kas_config: KasConfig,
        layer_paths: HashMap<String, Vec<PathBuf>>,
    ) -> Self {
        Self {
            build_dir: build_dir.as_ref().to_path_buf(),
            kas_config,
            layer_paths,
        }
    }

    /// Generate all configuration files
    pub async fn generate_all(&self) -> Result<(), ConfigError> {
        let conf_dir = self.build_dir.join("conf");
        tokio::fs::create_dir_all(&conf_dir)
            .await
            .map_err(|e| ConfigError::IoError(conf_dir.clone(), e.to_string()))?;

        self.generate_local_conf(&conf_dir).await?;
        self.generate_bblayers_conf(&conf_dir).await?;

        Ok(())
    }

    /// Generate local.conf
    async fn generate_local_conf(&self, conf_dir: &Path) -> Result<(), ConfigError> {
        let mut content = String::new();

        // Header
        content.push_str("#\n");
        content.push_str("# local.conf - Generated by Bitzel from kas configuration\n");
        content.push_str("#\n\n");

        // Machine and distro
        if let Some(machine) = &self.kas_config.machine {
            content.push_str(&format!("MACHINE ?= \"{machine}\"\n"));
        }

        if let Some(distro) = &self.kas_config.distro {
            content.push_str(&format!("DISTRO ?= \"{distro}\"\n"));
        }

        content.push('\n');

        // Default paths
        content.push_str("# Build directories\n");
        content.push_str("TMPDIR = \"${TOPDIR}/tmp\"\n");
        content.push_str("DL_DIR ?= \"${TOPDIR}/downloads\"\n");
        content.push_str("SSTATE_DIR ?= \"${TOPDIR}/sstate-cache\"\n");
        content.push('\n');

        // Bitzel cache directory
        content.push_str("# Bitzel cache (Bazel-style CAS)\n");
        content.push_str("BITZEL_CACHE_DIR ?= \"${TOPDIR}/bitzel-cache\"\n");
        content.push('\n');

        // Custom headers from kas
        if let Some(headers) = &self.kas_config.local_conf_header {
            content.push_str("# Custom configuration from kas\n");
            for (section_name, section_content) in headers {
                content.push_str(&format!("# Section: {section_name}\n"));
                content.push_str(section_content);
                content.push_str("\n\n");
            }
        }

        // Package management
        content.push_str("# Package management\n");
        content.push_str("PACKAGE_CLASSES ?= \"package_ipk\"\n");
        content.push('\n');

        // Parallelism
        content.push_str("# Build parallelism\n");
        content.push_str("BB_NUMBER_THREADS ?= \"${@oe.utils.cpu_count()}\"\n");
        content.push_str("PARALLEL_MAKE ?= \"-j ${@oe.utils.cpu_count()}\"\n");
        content.push('\n');

        // Write file
        let local_conf_path = conf_dir.join("local.conf");
        tokio::fs::write(&local_conf_path, content)
            .await
            .map_err(|e| ConfigError::IoError(local_conf_path.clone(), e.to_string()))?;

        Ok(())
    }

    /// Generate bblayers.conf
    async fn generate_bblayers_conf(&self, conf_dir: &Path) -> Result<(), ConfigError> {
        let mut content = String::new();

        // Header
        content.push_str("#\n");
        content.push_str("# bblayers.conf - Generated by Bitzel from kas configuration\n");
        content.push_str("#\n\n");

        content.push_str("LCONF_VERSION = \"7\"\n\n");

        // BBPATH
        content.push_str("BBPATH = \"${TOPDIR}\"\n");
        content.push_str("BBFILES ?= \"\"\n\n");

        // Custom headers from kas
        if let Some(headers) = &self.kas_config.bblayers_conf_header {
            content.push_str("# Custom configuration from kas\n");
            for (section_name, section_content) in headers {
                content.push_str(&format!("# Section: {section_name}\n"));
                content.push_str(section_content);
                content.push_str("\n\n");
            }
        }

        // BBLAYERS
        content.push_str("BBLAYERS ?= \" \\\n");

        for layers in self.layer_paths.values() {
            for layer_path in layers {
                content.push_str(&format!("  {} \\\n", layer_path.display()));
            }
        }

        content.push_str("\"\n");

        // Write file
        let bblayers_conf_path = conf_dir.join("bblayers.conf");
        tokio::fs::write(&bblayers_conf_path, content)
            .await
            .map_err(|e| ConfigError::IoError(bblayers_conf_path.clone(), e.to_string()))?;

        Ok(())
    }

    /// Generate environment setup script
    pub async fn generate_env_setup(&self) -> Result<(), ConfigError> {
        let mut content = String::new();

        // Header
        content.push_str("#!/bin/bash\n");
        content.push_str("#\n");
        content.push_str("# Environment setup script generated by Bitzel\n");
        content.push_str("#\n\n");

        content.push_str(&format!("export BUILDDIR=\"{}\"\n", self.build_dir.display()));

        // Custom environment variables from kas
        if let Some(env) = &self.kas_config.env {
            content.push_str("\n# Custom environment from kas\n");
            for (key, value) in env {
                content.push_str(&format!("export {key}=\"{value}\"\n"));
            }
        }

        content.push_str("\necho \"Build environment configured\"\n");
        content.push_str(&format!("echo \"  Build directory: {}\"\n", self.build_dir.display()));

        if let Some(machine) = &self.kas_config.machine {
            content.push_str(&format!("echo \"  Machine: {machine}\"\n"));
        }

        if let Some(distro) = &self.kas_config.distro {
            content.push_str(&format!("echo \"  Distro: {distro}\"\n"));
        }

        // Write file
        let env_setup_path = self.build_dir.join("setup-environment");
        tokio::fs::write(&env_setup_path, content)
            .await
            .map_err(|e| ConfigError::IoError(env_setup_path.clone(), e.to_string()))?;

        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = tokio::fs::metadata(&env_setup_path)
                .await
                .map_err(|e| ConfigError::IoError(env_setup_path.clone(), e.to_string()))?
                .permissions();
            perms.set_mode(0o755);
            tokio::fs::set_permissions(&env_setup_path, perms)
                .await
                .map_err(|e| ConfigError::IoError(env_setup_path.clone(), e.to_string()))?;
        }

        Ok(())
    }

    /// Get target list from kas config
    pub fn get_targets(&self) -> Vec<String> {
        self.kas_config
            .target
            .clone()
            .unwrap_or_else(|| vec!["core-image-minimal".to_string()])
    }
}

/// Configuration error types
#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    /// File system I/O error
    #[error("IO error at {0}: {1}")]
    IoError(PathBuf, String),

    /// Invalid configuration value
    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),

    /// Required configuration field is missing
    #[error("Missing required field: {0}")]
    MissingField(String),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::include_graph::{KasHeader, KasRepo};
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_config_generation() {
        let temp = TempDir::new().unwrap();

        let mut repos = HashMap::new();
        repos.insert(
            "poky".to_string(),
            KasRepo {
                url: Some("https://git.yoctoproject.org/git/poky".to_string()),
                refspec: Some("kirkstone".to_string()),
                branch: None,
                commit: None,
                tag: None,
                path: None,
                layers: HashMap::new(),
                patches: None,
            },
        );

        let config = KasConfig {
            header: KasHeader {
                version: 14,
                includes: None,
            },
            machine: Some("qemux86-64".to_string()),
            distro: Some("poky".to_string()),
            target: Some(vec!["core-image-minimal".to_string()]),
            repos,
            bblayers_conf_header: None,
            local_conf_header: None,
            env: None,
        };

        let generator = ConfigGenerator::new(temp.path(), config, HashMap::new());
        generator.generate_all().await.unwrap();

        let local_conf = temp.path().join("conf/local.conf");
        assert!(local_conf.exists());

        let content = tokio::fs::read_to_string(local_conf).await.unwrap();
        assert!(content.contains("MACHINE"));
        assert!(content.contains("qemux86-64"));
    }
}
